<!DOCTYPE html>
<html lang="en">
  
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Typelevel Laika + Helium Theme" />
  <title>Recursive ADT (Algebraic Data Types)</title>
  
  <meta name="author" content="Travis Brown"/>
  
  <meta name="author" content="Zach McCoy"/>
  
  <meta name="author" content="Darren Gibson"/>
  
  <meta name="author" content="Erlend Hamnaberg"/>
  
  
  <meta name="description" content="Circe docs"/>
  
  
  
  <link rel="icon" sizes="32x32" type="image/png" href="../images/circe_light_no_border_146x173.png"/>
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
  
  <link rel="stylesheet" type="text/css" href="../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../helium/site/laika-helium.css" />
  <script src="../helium/site/laika-helium.js"></script>
  
  
  <script> /* for avoiding page load transitions */ </script>
</head>

  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>
    
    
  </div>

  <a class="image-link" href="https://github.com/circe/circe"><img src="../images/circe_light_no_border_146x173.png"></a>

  <div class="row links">
    
    <a class="icon-link svg-link" href="https://github.com/circe/circe"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
    <a class="icon-link glyph-link" href="https://discord.gg/XF3CXcMzqD"><i class="icofont-laika chat" title="Chat">&#xeed5;</i></a>
    
  </div>  

</header>
    
    <nav id="sidebar">

  <div class="row">
    
    <a class="icon-link svg-link" href="https://github.com/circe/circe"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
    <a class="icon-link glyph-link" href="https://discord.gg/XF3CXcMzqD"><i class="icofont-laika chat" title="Chat">&#xeed5;</i></a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="../quickstart.html">Quick Start</a></li>
    <li class="level1 nav-leaf"><a href="../parsing.html">Parsing JSON</a></li>
    <li class="level1 nav-leaf"><a href="../cursors.html">Traversing and modifying JSON</a></li>
    <li class="level1 nav-node"><a href="index.html">Encoding and Decoding</a></li>
    <li class="level2 nav-leaf"><a href="semiauto-derivation.html">Semi-automatic Derivation</a></li>
    <li class="level2 nav-leaf"><a href="auto-derivation.html">Automatic Derivation</a></li>
    <li class="level2 nav-leaf"><a href="custom-codecs.html">Custom Codecs</a></li>
    <li class="level2 nav-leaf"><a href="adt.html">ADT (Algebraic Data Types)</a></li>
    <li class="level2 nav-leaf"><a href="testing.html">Codec Testing</a></li>
    <li class="level2 nav-leaf"><a href="known-issues.html">Warnings and known issues</a></li>
    <li class="level2 active nav-leaf"><a href="#">Recursive ADT (Algebraic Data Types)</a></li>
    <li class="level1 nav-leaf"><a href="../optics.html">Optics</a></li>
    <li class="level1 nav-leaf"><a href="../performance.html">Performance</a></li>
    <li class="level1 nav-header">Related Projects</li>
    <li class="level2 nav-leaf"><a href="https://github.com/circe/circe-fs2">circe-fs2</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/circe/circe-iteratee">circe-iteratee</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/circe/circe-generic-extras">circe-generic-extras</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/circe/circe-derivation">circe-derivation</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/circe/circe-optics">circe-optics</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/circe/circe-droste">circe-droste</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/circe/circe-spire">circe-spire</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/circe/circe-config">circe-config</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/circe/circe-yaml">circe-yaml</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/circe/circe-bson">circe-bson</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/circe/circe-schema">circe-schema</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/circe/circe-golden">circe-golden</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/circe/circe-json-schema">circe-json-schema</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/circe/circe-jackson">circe-jackson</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/circe/circe-argus">circe-argus</a></li>
  </ul>

</nav>

    <div id="container">

      
<nav id="page-nav">
  <p class="header"><a href="#">Recursive ADT (Algebraic Data Types)</a></p>

  <ul class="nav-list">
    <li class="level1 nav-node"><a href="#recursive-adt-encoding-and-decoding">Recursive ADT encoding and decoding</a></li>
    <li class="level2 nav-leaf"><a href="#recursive-decoder-example">Recursive <code>Decoder</code> example</a></li>
    <li class="level2 nav-leaf"><a href="#limitations">Limitations</a></li>
  </ul>

  <p class="footer"></p>
</nav>


      <main class="content">

        <h1 id="recursive-adt-algebraic-data-types" class="title">Recursive ADT (Algebraic Data Types)</h1>
        
        <h2 id="recursive-adt-encoding-and-decoding" class="section"><a class="anchor-link left" href="#recursive-adt-encoding-and-decoding"><i class="icofont-laika link">&#xef71;</i></a>Recursive ADT encoding and decoding</h2>
        <p>Certain shapes of data are difficult to write correct <code>Decoder</code>/<code>Encoder</code> instances for, 
        however much of the complexity can be avoided by leveraging the <code>Defer</code> typeclass from <code>cats</code>.</p>
        
        <h3 id="recursive-decoder-example" class="section"><a class="anchor-link left" href="#recursive-decoder-example"><i class="icofont-laika link">&#xef71;</i></a>Recursive <code>Decoder</code> example</h3>
        <p>It&#39;s important to understand the failure modes that are specific to writing a <code>Decoder</code> for a 
        recursive data structure, because <code>Defer</code> only resolves 3 of the 4.</p>
        <p>Consider the following ADT:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">io</span><span>.</span><span class="identifier">circe</span><span>.{</span><span class="type-name">Json</span><span>, </span><span class="type-name">Decoder</span><span>, </span><span class="type-name">HCursor</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">io</span><span>.</span><span class="identifier">circe</span><span>.</span><span class="type-name">Decoder</span><span>.{</span><span class="type-name">Result</span><span>, </span><span class="type-name">AccumulatingResult</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">io</span><span>.</span><span class="identifier">circe</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">all</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">left</span><span>: </span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>], </span><span class="identifier">right</span><span>: </span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]) </span><span class="keyword">extends</span><span> </span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Leaf</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">value</span><span>: </span><span class="type-name">A</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]</span></code></pre>
        
        <h4 id="first-attempt-stackoverflowerror-during-decoder-creation" class="section"><a class="anchor-link left" href="#first-attempt-stackoverflowerror-during-decoder-creation"><i class="icofont-laika link">&#xef71;</i></a>First Attempt: <code>StackOverflowError</code> during <code>Decoder</code> creation</h4>
        <p>And these encoder / decoder instances:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">branchDecoder</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Decoder</span><span>]: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>]] =
  </span><span class="type-name">Decoder</span><span>.</span><span class="identifier">forProduct2</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>], </span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>], </span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]](</span><span class="string-literal">&quot;l&quot;</span><span>, </span><span class="string-literal">&quot;r&quot;</span><span>)(</span><span class="type-name">Branch</span><span>.</span><span class="identifier">apply</span><span>)

</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">leafDecoder</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Decoder</span><span>]: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Leaf</span><span>[</span><span class="type-name">A</span><span>]] =
  </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">A</span><span>].</span><span class="identifier">at</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span>).</span><span class="identifier">map</span><span>(</span><span class="type-name">Leaf</span><span>(</span><span class="identifier">_</span><span>))

</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">treeDecoder</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Decoder</span><span>]: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]] =
  </span><span class="type-name">List</span><span>[</span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]]](
    </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>]].</span><span class="identifier">widen</span><span>,
    </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Leaf</span><span>[</span><span class="type-name">A</span><span>]].</span><span class="identifier">widen</span><span>
  ).</span><span class="identifier">reduceLeft</span><span>(</span><span class="identifier">_</span><span> </span><span class="identifier">or</span><span> </span><span class="identifier">_</span><span>)</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">decoder</span><span> = 
  </span><span class="keyword">try</span><span> </span><span class="identifier">implicitly</span><span>[</span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">Int</span><span>]]] 
  </span><span class="keyword">catch</span><span> {
    </span><span class="keyword">case</span><span> </span><span class="identifier">_</span><span>: </span><span class="type-name">StackOverflowError</span><span> =&gt; 
      </span><span class="type-name">Decoder</span><span>.</span><span class="identifier">failedWithMessage</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">Int</span><span>]](</span><span class="string-literal">&quot;Lookup caused StackOverflowError&quot;</span><span>)
  }
</span><span class="comment">// decoder: Decoder[Tree[Int]] = io.circe.Decoder$$anon$21@609cc653
</span><span>
</span><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span> := </span><span class="number-literal">1</span><span>).</span><span class="identifier">as</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">Int</span><span>]](</span><span class="identifier">decoder</span><span>)
</span><span class="comment">// res0: Result[Tree[Int]] = Left(
//   value = DecodingFailure at : Lookup caused StackOverflowError
// )</span></code></pre>
        <p>This implementation looks quite reasonable, however it will result in a <code>StackOverflowError</code> at runtime.
        This happens because <code>Tree</code> is generic, and it&#39;s <code>Decoder</code> instances must be generic <code>def</code>s, producing and
        endless loop of calls to <code>treeDecoder</code> and <code>branchDecoder</code>.</p>
        
        <h4 id="second-attempt-diverging-implicits-error" class="section"><a class="anchor-link left" href="#second-attempt-diverging-implicits-error"><i class="icofont-laika link">&#xef71;</i></a>Second Attempt: Diverging Implicits error</h4>
        <p>The <code>StackOverflowError</code> can be converted to a compilation error by adjusting the implicit parameters to be 
        more granular. This diverging implicits error is more clear about the source of the issue.</p>
        <pre><code class="nohighlight"><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">branchDecoder</span><span>[</span><span class="type-name">A</span><span>](</span><span class="keyword">implicit</span><span> </span><span class="type-name">TD</span><span>: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]]): </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>]] =
  </span><span class="type-name">Decoder</span><span>.</span><span class="identifier">forProduct2</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>], </span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>], </span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]](</span><span class="string-literal">&quot;l&quot;</span><span>, </span><span class="string-literal">&quot;r&quot;</span><span>)(
    </span><span class="type-name">Branch</span><span>.</span><span class="identifier">apply</span><span>
  )

</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">leafDecoder</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Decoder</span><span>]: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Leaf</span><span>[</span><span class="type-name">A</span><span>]] =
  </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">A</span><span>].</span><span class="identifier">at</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span>).</span><span class="identifier">map</span><span>(</span><span class="type-name">Leaf</span><span>(</span><span class="identifier">_</span><span>))

</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">treeDecoder</span><span>[</span><span class="type-name">A</span><span>](</span><span class="keyword">implicit</span><span> </span><span class="type-name">BD</span><span>: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>]], </span><span class="type-name">LD</span><span>: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Leaf</span><span>[</span><span class="type-name">A</span><span>]]): </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]] =
  </span><span class="type-name">List</span><span>[</span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]]](
    </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>]].</span><span class="identifier">widen</span><span>,
    </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Leaf</span><span>[</span><span class="type-name">A</span><span>]].</span><span class="identifier">widen</span><span>
  ).</span><span class="identifier">reduce</span><span>(</span><span class="identifier">_</span><span> </span><span class="identifier">or</span><span> </span><span class="identifier">_</span><span>)</span></code></pre>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">implicitly</span><span>[</span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">Int</span><span>]]]
</span><span class="comment">// error: diverging implicit expansion for type io.circe.Decoder[repl.MdocSession.MdocApp.Tree[Int]]
// starting with method branchDecoder
// implicitly[Decoder[Tree[Int]]]
//           ^</span></code></pre>
        
        <h4 id="third-attempt-undesirable-creation-of-decoder-instances" class="section"><a class="anchor-link left" href="#third-attempt-undesirable-creation-of-decoder-instances"><i class="icofont-laika link">&#xef71;</i></a>Third Attempt: Undesirable creation of <code>Decoder</code> instances</h4>
        <p>Switching to lazily creating the instances needed is a way to get past the diverging implicits issue, however the
        cost of this approach is the creation of a new instance of <code>Decoder</code> each time recursion occurs.</p>
        <pre><code class="nohighlight"><span class="keyword">var</span><span> </span><span class="identifier">instanceCounter</span><span> = </span><span class="number-literal">0</span><span>
</span><span class="comment">// instanceCounter: Int = 0
</span><span>
</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">branchDecoder</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Decoder</span><span>]: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>]] = {
  </span><span class="identifier">instanceCounter</span><span> += </span><span class="number-literal">1</span><span>
  </span><span class="type-name">Decoder</span><span>.</span><span class="identifier">instance</span><span> { </span><span class="identifier">c</span><span> =&gt;
    (</span><span class="identifier">c</span><span>.</span><span class="identifier">downField</span><span>(</span><span class="string-literal">&quot;l&quot;</span><span>).</span><span class="identifier">as</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]], </span><span class="identifier">c</span><span>.</span><span class="identifier">downField</span><span>(</span><span class="string-literal">&quot;r&quot;</span><span>).</span><span class="identifier">as</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]]).</span><span class="identifier">mapN</span><span>(</span><span class="type-name">Branch</span><span>.</span><span class="identifier">apply</span><span>)
  }
}

</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">leafDecoder</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Decoder</span><span>]: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Leaf</span><span>[</span><span class="type-name">A</span><span>]] = {
  </span><span class="identifier">instanceCounter</span><span> += </span><span class="number-literal">1</span><span>
  </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">A</span><span>].</span><span class="identifier">at</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span>).</span><span class="identifier">map</span><span>(</span><span class="type-name">Leaf</span><span>(</span><span class="identifier">_</span><span>))
}

</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">treeDecoder</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Decoder</span><span>]: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]] = {
  </span><span class="identifier">instanceCounter</span><span> += </span><span class="number-literal">1</span><span>
  </span><span class="type-name">Decoder</span><span>.</span><span class="identifier">instance</span><span> { </span><span class="identifier">c</span><span> =&gt;
    </span><span class="identifier">c</span><span>.</span><span class="identifier">as</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>]].</span><span class="identifier">orElse</span><span>(</span><span class="identifier">c</span><span>.</span><span class="identifier">as</span><span>[</span><span class="type-name">Leaf</span><span>[</span><span class="type-name">A</span><span>]])
  }
}</span></code></pre>
        <pre><code class="nohighlight"><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(
  </span><span class="string-literal">&quot;l&quot;</span><span> -&gt; </span><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span> := </span><span class="number-literal">1</span><span>),
  </span><span class="string-literal">&quot;r&quot;</span><span> -&gt; </span><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(
    </span><span class="string-literal">&quot;l&quot;</span><span> -&gt; </span><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span> := </span><span class="number-literal">2</span><span>),
    </span><span class="string-literal">&quot;r&quot;</span><span> -&gt; </span><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span> := </span><span class="number-literal">3</span><span>)
  )
).</span><span class="identifier">as</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">Int</span><span>]]
</span><span class="comment">// res2: Result[Tree[Int]] = Right(
//   value = Branch(
//     left = Leaf(value = 1),
//     right = Branch(left = Leaf(value = 2), right = Leaf(value = 3))
//   )
// )
</span><span>
</span><span class="identifier">instanceCounter</span><span>
</span><span class="comment">// res3: Int = 19</span></code></pre>
        
        <h4 id="fourth-attempt-a-workable-solution" class="section"><a class="anchor-link left" href="#fourth-attempt-a-workable-solution"><i class="icofont-laika link">&#xef71;</i></a>Fourth Attempt: A workable solution</h4>
        <p>The solution to the previous issues is to generate the instances once, and cache them.</p>
        <pre><code class="nohighlight"><span class="keyword">var</span><span> </span><span class="identifier">instanceCounter</span><span> = </span><span class="number-literal">0</span><span>
</span><span class="comment">// instanceCounter: Int = 0
</span><span>
</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">branchDecoder</span><span>[</span><span class="type-name">A</span><span>](</span><span class="keyword">implicit</span><span> </span><span class="type-name">DTA</span><span>: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]]): </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>]] = {
  </span><span class="identifier">instanceCounter</span><span> += </span><span class="number-literal">1</span><span>
  </span><span class="type-name">Decoder</span><span>.</span><span class="identifier">forProduct2</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>], </span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>], </span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]](</span><span class="string-literal">&quot;l&quot;</span><span>, </span><span class="string-literal">&quot;r&quot;</span><span>)(</span><span class="type-name">Branch</span><span>.</span><span class="identifier">apply</span><span>)
}

</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">leafDecoder</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Decoder</span><span>]: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Leaf</span><span>[</span><span class="type-name">A</span><span>]] = {
  </span><span class="identifier">instanceCounter</span><span> += </span><span class="number-literal">1</span><span>
  </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">A</span><span>].</span><span class="identifier">at</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span>).</span><span class="identifier">map</span><span>(</span><span class="type-name">Leaf</span><span>(</span><span class="identifier">_</span><span>))
}

</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">treeDecoder</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Decoder</span><span>]: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]] = {
  </span><span class="identifier">instanceCounter</span><span> += </span><span class="number-literal">1</span><span>
  </span><span class="keyword">new</span><span> </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]] {
    </span><span class="keyword">private</span><span> </span><span class="keyword">implicit</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">self</span><span>: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]] = </span><span class="keyword">this</span><span>
    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">delegate</span><span> =
      </span><span class="type-name">List</span><span>[</span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]]](
        </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>]].</span><span class="identifier">widen</span><span>,
        </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Leaf</span><span>[</span><span class="type-name">A</span><span>]].</span><span class="identifier">widen</span><span>
      ).</span><span class="identifier">reduce</span><span>(</span><span class="identifier">_</span><span> </span><span class="identifier">or</span><span> </span><span class="identifier">_</span><span>)
      
    </span><span class="keyword">override</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">c</span><span>: </span><span class="type-name">HCursor</span><span>): </span><span class="type-name">Result</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]] = </span><span class="identifier">delegate</span><span>(</span><span class="identifier">c</span><span>)
  }
}</span></code></pre>
        <pre><code class="nohighlight"><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(
  </span><span class="string-literal">&quot;l&quot;</span><span> -&gt; </span><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span> := </span><span class="number-literal">1</span><span>),
  </span><span class="string-literal">&quot;r&quot;</span><span> -&gt; </span><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(
    </span><span class="string-literal">&quot;l&quot;</span><span> -&gt; </span><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span> := </span><span class="number-literal">2</span><span>),
    </span><span class="string-literal">&quot;r&quot;</span><span> -&gt; </span><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span> := </span><span class="number-literal">3</span><span>)
  )
).</span><span class="identifier">as</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">Int</span><span>]]
</span><span class="comment">// res4: Result[Tree[Int]] = Right(
//   value = Branch(
//     left = Leaf(value = 1),
//     right = Branch(left = Leaf(value = 2), right = Leaf(value = 3))
//   )
// )
</span><span>
</span><span class="identifier">instanceCounter</span><span>
</span><span class="comment">// res5: Int = 3</span></code></pre>
        <p>Note that, because <code>delegate</code> is a fixed instance, it is not necessary to explicitly cache
        <code>branchDecoder</code> or <code>leafDecoder</code>.</p>
        <p>This implementation solves <em>most</em> of the issues with a recursive decoder, at the cost of 
        being annoying to write, and easy to break by omitting <code>private implicit val self: Decoder[Tree[A]] = this</code>,
        which will cause this decoder to produce a <code>StackOverflowError</code> at runtime, but the compiler 
        won&#39;t complain about removing it.</p>
        
        <h4 id="fifth-attempt-a-more-elegant-solution" class="section"><a class="anchor-link left" href="#fifth-attempt-a-more-elegant-solution"><i class="icofont-laika link">&#xef71;</i></a>Fifth Attempt: A more elegant solution</h4>
        <p>The <code>Defer</code> typeclass allows us to write <code>Decoder</code>s and <code>Encoders</code> that have access to their eventual 
        instance, enabling us to write an equivalent instances in a more natural and less fragile fashion. 
        This can be done directly, using <code>Defer[Decoder].fix</code>, or the <code>recursive</code> helper provided on the <code>Decoder</code> 
        and <code>Encoder</code> companion objects.</p>
        <p>The <code>Decoder</code> instances for <code>Tree</code> using <code>Decoder.recursive</code> would look like this: </p>
        <pre><code class="nohighlight"><span class="keyword">var</span><span> </span><span class="identifier">instanceCounter</span><span> = </span><span class="number-literal">0</span><span>
</span><span class="comment">// instanceCounter: Int = 0
</span><span>
</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">branchDecoder</span><span>[</span><span class="type-name">A</span><span>](</span><span class="keyword">implicit</span><span> </span><span class="type-name">DTA</span><span>: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]]): </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>]] = {
  </span><span class="identifier">instanceCounter</span><span> += </span><span class="number-literal">1</span><span>
  </span><span class="type-name">Decoder</span><span>.</span><span class="identifier">forProduct2</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>], </span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>], </span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]](</span><span class="string-literal">&quot;l&quot;</span><span>, </span><span class="string-literal">&quot;r&quot;</span><span>)(</span><span class="type-name">Branch</span><span>.</span><span class="identifier">apply</span><span>)
}

</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">leafDecoder</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Decoder</span><span>]: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Leaf</span><span>[</span><span class="type-name">A</span><span>]] = {
  </span><span class="identifier">instanceCounter</span><span> += </span><span class="number-literal">1</span><span>
  </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">A</span><span>].</span><span class="identifier">at</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span>).</span><span class="identifier">map</span><span>(</span><span class="type-name">Leaf</span><span>(</span><span class="identifier">_</span><span>))
}

</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">treeDecoder</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Decoder</span><span>]: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]] = {
  </span><span class="identifier">instanceCounter</span><span> += </span><span class="number-literal">1</span><span>
  </span><span class="type-name">Decoder</span><span>.</span><span class="identifier">recursive</span><span> { </span><span class="keyword">implicit</span><span> </span><span class="identifier">recurse</span><span> =&gt;
    </span><span class="type-name">List</span><span>[</span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]]](
      </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>]].</span><span class="identifier">widen</span><span>,
      </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Leaf</span><span>[</span><span class="type-name">A</span><span>]].</span><span class="identifier">widen</span><span>
    ).</span><span class="identifier">reduce</span><span>(</span><span class="identifier">_</span><span> </span><span class="identifier">or</span><span> </span><span class="identifier">_</span><span>)
  }
}</span></code></pre>
        <pre><code class="nohighlight"><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(
  </span><span class="string-literal">&quot;l&quot;</span><span> -&gt; </span><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span> := </span><span class="number-literal">1</span><span>),
  </span><span class="string-literal">&quot;r&quot;</span><span> -&gt; </span><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(
    </span><span class="string-literal">&quot;l&quot;</span><span> -&gt; </span><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span> := </span><span class="number-literal">2</span><span>),
    </span><span class="string-literal">&quot;r&quot;</span><span> -&gt; </span><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span> := </span><span class="number-literal">3</span><span>)
  )
).</span><span class="identifier">as</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">Int</span><span>]]
</span><span class="comment">// res6: Result[Tree[Int]] = Right(
//   value = Branch(
//     left = Leaf(value = 1),
//     right = Branch(left = Leaf(value = 2), right = Leaf(value = 3))
//   )
// )
</span><span>
</span><span class="identifier">instanceCounter</span><span>
</span><span class="comment">// res7: Int = 3</span></code></pre>
        <p>Note that, in the same manner that caching <code>delegate</code> implicitly caches the branch and leaf decoders, 
        because <code>treeDecoder</code> provides a fixed instance, it is not necessary to use <code>Decoder.recursive</code> to write
        <code>branchDecoder</code> or <code>leafDecoder</code></p>
        
        <h3 id="limitations" class="section"><a class="anchor-link left" href="#limitations"><i class="icofont-laika link">&#xef71;</i></a>Limitations</h3>
        <p>While both the fourth and fifth attempts avoid the issues of the previous attempts, they are not
        perfect. Because the recursive calls are not tail recursive, they are not fully stack safe. This
        is generally not an issue for data structures that have a depth of at most <code>log(size)</code>, linear 
        structures (like a linked list) could run into trouble.</p>
        <pre><code class="nohighlight"><span class="keyword">var</span><span> </span><span class="identifier">instanceCounter</span><span> = </span><span class="number-literal">0</span><span>
</span><span class="comment">// instanceCounter: Int = 0
</span><span>
</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">branchDecoder</span><span>[</span><span class="type-name">A</span><span>](</span><span class="keyword">implicit</span><span> </span><span class="type-name">DTA</span><span>: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]]): </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>]] = {
  </span><span class="identifier">instanceCounter</span><span> += </span><span class="number-literal">1</span><span>
  </span><span class="type-name">Decoder</span><span>.</span><span class="identifier">forProduct2</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>], </span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>], </span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]](</span><span class="string-literal">&quot;l&quot;</span><span>, </span><span class="string-literal">&quot;r&quot;</span><span>)(</span><span class="type-name">Branch</span><span>.</span><span class="identifier">apply</span><span>)
}

</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">leafDecoder</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Decoder</span><span>]: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Leaf</span><span>[</span><span class="type-name">A</span><span>]] = {
  </span><span class="identifier">instanceCounter</span><span> += </span><span class="number-literal">1</span><span>
  </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">A</span><span>].</span><span class="identifier">at</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span>).</span><span class="identifier">map</span><span>(</span><span class="type-name">Leaf</span><span>(</span><span class="identifier">_</span><span>))
}

</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">treeDecoder</span><span>[</span><span class="type-name">A</span><span>: </span><span class="type-name">Decoder</span><span>]: </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]] = {
  </span><span class="identifier">instanceCounter</span><span> += </span><span class="number-literal">1</span><span>
  </span><span class="type-name">Decoder</span><span>.</span><span class="identifier">recursive</span><span> { </span><span class="keyword">implicit</span><span> </span><span class="identifier">recurse</span><span> =&gt;
    </span><span class="type-name">List</span><span>[</span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">A</span><span>]]](
      </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Branch</span><span>[</span><span class="type-name">A</span><span>]].</span><span class="identifier">widen</span><span>,
      </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Leaf</span><span>[</span><span class="type-name">A</span><span>]].</span><span class="identifier">widen</span><span>
    ).</span><span class="identifier">reduce</span><span>(</span><span class="identifier">_</span><span> </span><span class="identifier">or</span><span> </span><span class="identifier">_</span><span>)
  }
}</span></code></pre>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">decoder</span><span> = </span><span class="type-name">Decoder</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">Int</span><span>]]
</span><span class="comment">// decoder: Decoder[Tree[Int]] = io.circe.Decoder$$anon$9@2a087e80
</span><span class="keyword">try</span><span> 
  </span><span class="type-name">List</span><span>
    .</span><span class="identifier">range</span><span>(</span><span class="number-literal">0</span><span>, </span><span class="number-literal">10000</span><span>)
    .</span><span class="identifier">map</span><span>(</span><span class="identifier">i</span><span> =&gt; </span><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(</span><span class="string-literal">&quot;v&quot;</span><span> := </span><span class="identifier">i</span><span>))
    .</span><span class="identifier">reduceLeft</span><span> { (</span><span class="identifier">a</span><span>, </span><span class="identifier">b</span><span>) =&gt;
      </span><span class="type-name">Json</span><span>.</span><span class="identifier">obj</span><span>(</span><span class="string-literal">&quot;l&quot;</span><span> -&gt; </span><span class="identifier">a</span><span>, </span><span class="string-literal">&quot;r&quot;</span><span> -&gt; </span><span class="identifier">b</span><span>)
    }
    .</span><span class="identifier">as</span><span>[</span><span class="type-name">Tree</span><span>[</span><span class="type-name">Int</span><span>]](</span><span class="identifier">decoder</span><span>)
</span><span class="keyword">catch</span><span> {
  </span><span class="keyword">case</span><span> </span><span class="identifier">_</span><span>: </span><span class="type-name">StackOverflowError</span><span> =&gt; </span><span class="type-name">Leaf</span><span>(-</span><span class="number-literal">1</span><span>).</span><span class="identifier">asRight</span><span>
}
</span><span class="comment">// res8: Result[Tree[Int]] = Right(value = Leaf(value = -1))
</span><span>
</span><span class="identifier">instanceCounter</span><span>
</span><span class="comment">// res9: Int = 3</span></code></pre>
        <p>Note that despite the successful creation of a <code>Decoder[Tree[Int]]</code> instance, and the number of <code>Decoder</code> 
        instances remaining constant at 3, the size of the unbalanced <code>Tree[Int]</code> represented in the JSON still
        caused a <code>StackOverflowError</code>.</p>

        
<hr class="footer-rule"/>
<footer>
  Site generated by <a href="https://typelevel.org/Laika/">Laika</a> with the Helium theme.
</footer>


      </main>

    </div>

  </body>

</html>